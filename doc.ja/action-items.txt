* TODO bear版 と PATH版

** bear版の問題点

1) MAC OSX では以下の問題がある
http://d.hatena.ne.jp/kimuraw/20150919/p1 から抜粋
---------------------------------------------------------------------------------------
WWDC 2015のセッション706:”Security and Your Apps”(ASCIIwwdc)で説明されているように、
保護される領域（/Systemや/usr/binなど）にあるバイナリではDYLD_*環境変数は問答無用で無視
されるようになっています。
---------------------------------------------------------------------------------------
このため、コンパイラを起動するプログラム (例えば make,sh) が保護される領域にインストール
されているとそこから起動されるコンパイラが cmdrec で記録できない。
sh や コンパイラが該当するためほとんどダメ。

2) MAC OSX では AppleExportedSymbolsList を使うと dyld が cmdpreload をリンク出来ない

** PATH版

*** cmdrec
1) cmdrec のプロセス一覧をみる
2) 存在しないプロセスIDの ~/.cmdskin.<ID> フォルダを削除
3) 自分のプロセスIDの ~/.cmdskin.<ID> フォルダがあれば削除
4) ~/.cmdskin.<ID> フォルダを作成
5) cmdrec.conf から記録したいコマンド名のリストを得る
6) ~/.cmdskin.<ID> フォルダ内に記録したいコマンドのシンボリックリンクを cmdskin に張る
7) 環境変数 PATH の頭に ~/.cmdskin.<ID> を追加
8) 引数を system する
9) ~/.cmdskin.<ID> フォルダを削除

*** cmdskin
1) ~/.cmdrec.db にコマンド引数を記録
2) 環境変数 PATH の頭から ~/.cmdskin.<ID> を削除
3) 実プログラムを exec する

** PATH版の問題点

1) cmdrec の引数プログラムやその子孫プロセスで PATH 変数を書き換えることに対応出来ない
  → 記録したいコマンド名のリストが変化して cmdskin が呼ばれなくなるから
2) make などが子プロセスを PATH から検索せずに直接絶対パスで起動する場合に対応出来ない
  → cmdskin が呼ばれなくなるから
  → 例：cmake は絶対パスでコンパイラを起動する?
  → cmake は PATH から検索してる？


* TODO cmdplay でレコードが見つからなかった場合はそれなりに動作させる。
 1) パターンが一つも見つからなかったら、NG。
 2) パターンが一つもしくは複数見つかったら、それぞれについてレコードを検索する。
 3) レコードが複数見つかったパターンが一つでもあれば、NG。
 4) レコードが一つだけ見つかったパターンを集める。集合Aとする。
 5) レコードが見つからなかったパターンを集める。集合Bとする。
 6) 集合Aの要素数が2以上なら、NG。
 7) 集合Aの要素数が1なら、OK。これを起動する。
 8) 集合Aの要素数が0なら、集合Bの要素数を調べる。
 9) 集合Bの要素数が2以上なら、NG。
10) 集合Bの要素数が1なら、OK。recargs/recfile/reccmd/reccwdを捏造して、これを起動する。
11) 集合Bの要素数が0なら、NG。

* TODO cmdrec で複数の file を指定した場合は、それぞれについてレコードを生成する。

* TODO 上記 6) や 9) の場合、複数起動して、出力をシリアライズしてまとめる。

* DONE sigchild を受けたらすぐに終了するのではなく、受信をすべて完了してから終了する。

# Local Variables:
# mode: howm
# End:
